#include "../lib/MQuad.hpp"

	//parent defines which quad this quad is subordinate to
	//vertexes is main quad data (height), ef editet also changes parent data (and data shared with it's "siblings")
	//normals can be derived from the parent, or "baked" in the quad (also updates parent normals)
	//height defines the array height (second bracket)
	//width defines array width (first bracket)
	//the offsets define the offset from the main parents origin position

	MQuad::MQuad(MQuad* parent, float*** vertexes, glm::vec3*** normals, int height, int width, int offsetX, int offsetY, glm::mat4 model_matrix)
		: Entity(generateMesh()) {

		this->width = width;
		this->height = height;
		this->parent = parent;
		this->vertexes = vertexes;
		this->normals = normals;
		this->offsetX = offsetX;
		this->offsetY = offsetY;

		setCenter();
		setRadius();

		this->model_matrix = model_matrix;
		renderState = true;

		_mesh
			->addBuffer("m",
				[](GLuint id) {
			glBindBuffer(GL_ARRAY_BUFFER, id);
			glBufferData(GL_ARRAY_BUFFER, sizeof(glm::mat4), NULL, GL_STATIC_DRAW); // Will only be uploaded once

			for (int i = 0; i < 4; i++) {
				glEnableVertexAttribArray(ShaderAttributeID::m + i);
				glVertexAttribPointer(ShaderAttributeID::m + i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (GLvoid*)(sizeof(glm::vec4) * i));
				glVertexAttribDivisor(ShaderAttributeID::m + i, 1);
			}

			glBindBuffer(GL_ARRAY_BUFFER, 0);
		})
			.finalize();
	}
	
	std::shared_ptr<Mesh> MQuad::generateMesh() {
		std::vector<Vertex> vertexVector;
		for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				glm::vec3 pos((float)x, *vertexes[x][y], (float)y);

				vertexVector.push_back(Vertex{ pos,
					glm::vec3(0.0f,1.0f,0.0f),
					glm::vec3(1.0f,1.0f,1.0f),
					glm::vec2(0.0f,1.0f),
					glm::vec3(0.0f,1.0f,0.0f) });
			}
		}
		std::vector<GLuint> indVector;
		for (int x = 0; x < width - 1; x++) {
			for (int y = 0; y < height - 1; y++) {
				indVector.push_back(width + x);//lower left of quad
				indVector.push_back(x);
				indVector.push_back(width + 1);

				indVector.push_back(x + 1);//upper right of quad
				indVector.push_back(x);
				indVector.push_back(width + 1);
			}
		}

		return std::make_shared<Mesh>(vertexVector, indVector);
	}

	void MQuad::generateTangents() {

	}

	void MQuad::setChildren(MQuad* children[4]) {//assign new quads as children to this quad
		for (int i = 0; i < 4; i++) {
			this->children[i] = children[i];
		}
	}

	int MQuad::getWidth() {
		return width;
	}
	int MQuad::getHeight() {
		return height;
	}

	MQuad* MQuad::getChild(int pos) {//return child, 0-3 as values
		return children[pos];
	}

	float*** MQuad::getVertexes() {//return all vertex values (for rendering)
		return vertexes;
	}

	glm::vec3*** MQuad::getNormals() {//return all normals (also for rendering)
		return normals;
	}

	int MQuad::getOffsetX() {
		return offsetX;
	}

	int MQuad::getOffsetY() {
		return offsetY;
	}

	glm::vec3* MQuad::selectNormal(float x, float y, float scale) {//returns the pre-computed normal for a vertex at given position

		float xs = x / scale;//scale to localspace
		float ys = y / scale;

		//check if xs and ys are inside the "mesh space" if (xs < width && xs<) // !!!FIX THIS!!!

		int Xaprox = nearbyintf(xs);//round to find nearest int (vertex)
		int XaproxPartner;
		if (Xaprox - xs < 0) {//xs larger than Xaprox, xs has been rounded down (result negative)
			XaproxPartner = Xaprox + 1;
		}
		else {//xs smaller than Xaprox, xs has been rounded up (result positive)
			Xaprox--;
			XaproxPartner = Xaprox + 1;
		}

		int Yaprox = nearbyintf(ys);//round to find nearest int (vertex)
		int YaproxPartner;
		if (Yaprox - ys < 0) {//ys larger than Yaprox, ys has been rounded down (result negative)
			YaproxPartner = Yaprox + 1;
		}
		else {//ys smaller than Yaprox, ys has been rounded up (result positive)
			Yaprox--;
			YaproxPartner = Yaprox + 1;
		}

		glm::vec2 downLeft(Xaprox, YaproxPartner);
		glm::vec2 upRight(XaproxPartner, Yaprox);
		glm::vec2 p(xs, ys);
		glm::vec2 d1 = p - downLeft;
		glm::vec2 d2 = p - upRight;

		if (d1.length() < d2.length()) {//d1 is dominant, the normal we seek is in the triangle in the bottom left of the quad
			return normals[Xaprox][Yaprox];
		}
		else {//else its the top right one
			return normals[(Xaprox * 2) + 1][Yaprox];
		}
	}

	void MQuad::setRadius() {//Used for the culling process, if sphere generated by the center and the radius intersects with the frustrum the quad will be rendered
		radius = 0.0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				glm::vec3 point((float)x, (float)y, *vertexes[x][y]);
				float length = glm::length(point - center);
				if (length>radius) {
					radius = length;
				}
			}
		}
	}

	void MQuad::setCenter() {//defines the quads center from its average height and offset position
		float avgHeight = 0.0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				avgHeight += *vertexes[x][y];
			}
		}
		avgHeight /= (height*width);

		center = glm::vec3(width / 2, height / 2, avgHeight);
	}

	float MQuad::getRadius() {
		return radius;
	}

	void MQuad::setVertexValue(int x, int y, float val) {//can manipulate the height of a vertex, a call to MapTools::calculateNormals() should be performed afterwards
		*vertexes[x][y] = val;
	}

	string MQuad::printAll() {//returns the information for THIS QUAD and ALL under it (debug)
		stringstream OUTPUT;
		OUTPUT << print();
		for (int i = 0; i < 4; i++) {
			if (children[i] != nullptr) {
				OUTPUT << children[i]->printAll();
			}
		}
		return OUTPUT.str();
	}

	string MQuad::printVec3(glm::vec3 &in) {//prints a glm::vec3 in a nice way (debug)
		stringstream OUTPUT;
		OUTPUT << "(" << in.x << ", " << in.y << ", " << in.z << ")";
		return OUTPUT.str();
	}

	string MQuad::print() {//main quad printer (debug)
		stringstream OUTPUT;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				OUTPUT << setw(3) << setfill('0') << *vertexes[x][y] << " ";
			}
			if (y == 0) {
				OUTPUT << "	Width: " << width << " Offset: " << offsetX;
			}
			if (y == 1) {
				OUTPUT << "	Height: " << height << " Offset: " << offsetY;
			}
			if (y == 2) {
				OUTPUT << "	Radius: " << radius << " Center: " << printVec3(center);
			}
			OUTPUT << endl;
		}
		OUTPUT << endl;
		return OUTPUT.str();
	}

	bool MQuad::test(glm::vec4* planes) {//the culling process (planes length = 6, any less and there will be trouble)
		for (int i = 0; i < 6; i++) {
			float d = (planes[i].x * center.x) + (planes[i].y * center.y) + (planes[i].z * center.z) + planes[i].w;//determine distance between sphere and plane
			if (d < 0 && d < radius) {//might have to be switched
				renderState = false;
				return false;//the sphere is outside on of the planes, exit early
			}
		}
		if (children[0] != nullptr) {//if the quad has children, testing continues to them
			for (int i = 0; i < 4; i++) {
				children[i]->test(planes);
			}
		}
		else {//if the quad does not have any children, the testing stops and the quad will be rendered
			renderState = true;
		}

		return true;
	}

	void MQuad::render() {
		if (renderState) {
			_mesh->render();
		}
		else {
			for (int i = 0; i < 4; i++) {
				children[i]->render();
			}
		}
	}

	float MQuad::calcHeight(glm::vec3 position, float scale) {//used for calculating the height of a point on the heightmap (for movement and intersection)
		glm::vec3 normal = *selectNormal(position.x, position.z, scale);

		//code goes here, use selectNormal

		return 0;
	}

	glm::mat4 MQuad::getModelMatrix() {
		return model_matrix;
	}

	MQuad::~MQuad() {

		if (children[0] != nullptr) {
			for (int i = 0; i < 4; i++) {
				delete children[i];
			}
		}

		if (parent == nullptr) {
			for (int i = 0; i < width; i++) {
				for (int j = 0; j < height; j++) {
					delete[] vertexes[i][j];
				}
			}
			delete vertexes;


			for (int i = 0; i < (width - 1) * 2; i++) {
				for (int j = 0; j < height - 1; j++) {
					delete[] normals[i][j];
				}
				delete[] normals[i];
			}
			delete normals;
		}
	}

